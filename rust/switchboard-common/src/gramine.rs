use crate::SbError;

use getrandom::getrandom;
use sha2::{Digest, Sha256};
use std::fs;
use std::result::Result;

/// `Gramine`: Gramine is a virtualized runtime used to manage vanilla binaries
/// to execute in an SGX execution environment.  This struct allows access to
/// specific overrides that come out-of-the-box with Gramine.
pub struct Gramine;

impl Gramine {
    /// `Gramine::generate_quote`: This call allows the user to progmatically
    /// create a signature, or "quote" that can prove some piece of data was
    /// generated by a specific enclave. This quote contains a field, "MR_ENCLAVE"
    /// Which holds a measurement of the code that generated the signature.
    ///
    /// # Parameters:
    /// - `user_data`: This is an arbitrary piece of data that can be attached
    /// to the signature for other parties to verify that this data was
    /// produced in an enclave with a MR_ENCLAVE measurement
    ///
    /// # Returns
    /// `Vec<u8>` of a buffer containing the quote/signature
    pub fn generate_quote(user_data: &[u8]) -> Result<Vec<u8>, SbError> {
        let hash_result = Sha256::digest(user_data);
        Gramine::generate_hashed_data_quote(hash_result.try_into().unwrap())
    }

    /// `Gramine::generate_hashed_quote`: This call allows the user to progmatically
    /// create a signature, or "quote" that can prove some piece of data was
    /// generated by a specific enclave. This quote contains a field, "MR_ENCLAVE"
    /// Which holds a measurement of the code that generated the signature.
    ///
    /// # Parameters:
    /// - `user_data`: This is an arbitrary piece of data that can be attached
    /// to the signature for other parties to verify that this data was
    /// produced in an enclave with a MR_ENCLAVE measurement
    ///
    /// # Returns
    /// `Vec<u8>` of a buffer containing the quote/signature
    pub fn generate_hashed_data_quote(user_data: [u8; 32]) -> Result<Vec<u8>, SbError> {
        if let Err(_) = fs::metadata("/dev/attestation/quote") {
            return Err(SbError::SgxError);
        }
        let mut data = [0u8; 64];
        data[..32].copy_from_slice(&user_data);

        let user_report_data_path = "/dev/attestation/user_report_data";
        if fs::write(user_report_data_path, &data[..]).is_err() {
            return Err(SbError::SgxWriteError);
        }

        fs::read("/dev/attestation/quote").map_err(|_| SbError::SgxError)
    }

    /// `read_rand`: Gramine provides convinient accessors to read randomness
    /// that could not be predicted outside the enclave. Gramine will intercept
    /// calls to the getrandom syscall, /dev/random, and /dev/urandom to use
    /// SGX sourced randomness instead.
    ///
    /// # Relavent documentation:
    /// - <https://gramine.readthedocs.io/en/latest/devel/features.html#randomness>
    ///
    /// # Parameters:
    /// - `buf`: the buffer to write the output randomness to.
    ///
    /// # Returns
    /// Error on failure.
    pub fn read_rand(buf: &mut [u8]) -> Result<(), SbError> {
        // https://gramine.readthedocs.io/en/latest/devel/features.html#randomness
        getrandom(buf).map_err(|_| SbError::SgxError)
    }

    // /// `read_rand_unsafe`: Gramine provides convinient accessors to read randomness
    // /// that could not be predicted outside the enclave. Gramine will intercept
    // /// calls to the getrandom syscall, /dev/random, and /dev/urandom to use
    // /// SGX sourced randomness instead.
    // ///
    // /// # Relavent documentation:
    // /// - <https://gramine.readthedocs.io/en/latest/devel/features.html#randomness>
    // ///
    // /// # Parameters:
    // /// - `buf`: the buffer to write the output randomness to.
    // ///
    // /// # Returns
    // /// Error on failure.
    // #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
    // pub fn read_rand_unsafe(output: &mut [u8]) -> std::result::Result<(), SbError> {
    //     // https://is.gd/vlVLpC
    //     // https://github.com/rust-random/getrandom/blob/master/src/linux_android.rs#L17-L48
    //     // Gramine direct documentation: https://tinyurl.com/2hfc8n6y
    //     let buf = output.as_mut_ptr() as *mut libc::c_void;
    //     let buflen: libc::ssize_t = output.len().try_into().unwrap();
    //     let res = unsafe { libc::syscall(libc::SYS_getrandom, buf, buflen, 0) as libc::ssize_t };
    //     if res != buflen {
    //         return Err(SbError::SgxError);
    //     }
    //     Ok(())
    // }
}
