"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3304],{54852:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>f});var a=t(49231);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=a.createContext({}),u=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(d.Provider,{value:n},e.children)},l="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},v=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),l=u(t),v=r,f=l["".concat(d,".").concat(v)]||l[v]||m[v]||i;return t?a.createElement(f,s(s({ref:n},c),{},{components:t})):a.createElement(f,s({ref:n},c))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=v;var o={};for(var d in n)hasOwnProperty.call(n,d)&&(o[d]=n[d]);o.originalType=e,o[l]="string"==typeof e?e:r,s[1]=o;for(var u=2;u<i;u++)s[u]=t[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}v.displayName="MDXCreateElement"},29345:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var a=t(95634),r=(t(49231),t(54852));const i={title:"Switchboard.sol",keywords:["Switchboard","oracle network","evm"]},s=void 0,o={unversionedId:"evm/dev/switchboard-sol",id:"evm/dev/switchboard-sol",title:"Switchboard.sol",description:"Switchboard.sol is a Solidity interface to help you migrate legacy oracles to a",source:"@site/docs/202-evm/70-dev/10-switchboard-sol.mdx",sourceDirName:"202-evm/70-dev",slug:"/evm/dev/switchboard-sol",permalink:"/evm/dev/switchboard-sol",draft:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"Switchboard.sol",keywords:["Switchboard","oracle network","evm"]},sidebar:"sidebar",previous:{title:"Developer Resources",permalink:"/evm/dev/"},next:{title:"FunctionsClient.sol",permalink:"/evm/dev/functions-client-sol"}},d={},u=[{value:"Hardhat Setup",id:"hardhat-setup",level:2},{value:"Example",id:"example",level:2},{value:"Source Code",id:"source-code",level:2}],c={toc:u},l="wrapper";function m(e){let{components:n,...t}=e;return(0,r.kt)(l,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Switchboard.sol is a Solidity interface to help you migrate legacy oracles to a\nSwitchboard interface."),(0,r.kt)("h2",{id:"hardhat-setup"},"Hardhat Setup"),(0,r.kt)("p",null,"Add ",(0,r.kt)("inlineCode",{parentName:"p"},"@switchboard-xyz/evm.js")," to your Hardhat project"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm i -D @switchboard-xyz/evm.js\n")),(0,r.kt)("p",null,"Then import it into your Solidity contract with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'// Get the Switchboard Library - this is the Core Mainnet Deployment, you can swap this for one of the networks below\nimport {Switchboard} from "@switchboard-xyz/evm.js/contracts/core/testnet/Switchboard.sol";\n\n/*\n * NOTE: replace with one of the following imports to use an actual network deployment\n * import {Switchboard} from "@switchboard-xyz/evm.js/contracts/core/testnet/Switchboard.sol";\n * import {Switchboard} from "@switchboard-xyz/evm.js/contracts/core/Switchboard.sol";\n * import {Switchboard} from "@switchboard-xyz/evm.js/contracts/arbitrum/testnet/Switchboard.sol";\n * import {Switchboard} from "@switchboard-xyz/evm.js/contracts/arbitrum/Switchboard.sol";\n * etc...\n */\n')),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Get the Switchboard Library - this is the Core Mainnet Deployment, you can swap this for one of the networks below\nimport {Switchboard} from "@switchboard-xyz/evm.js/contracts/core/testnet/Switchboard.sol";\n\ncontract SwitchboardReceiver {\n    uint256 public randomValue;\n    address functionId;\n\n    event NewRandomValue(uint256 value);\n\n    function callback(uint256 value) external {\n        // extract the sender from the callback, this validates that the switchboard contract called this function\n        address encodedFunctionId = Switchboard.getEncodedFunctionId();\n\n        // set functionId to the sender if it\'s empty and the sender is the switchboard\n        if (functionId == address(0)) {\n            functionId = encodedFunctionId;\n        }\n\n        // make sure the encoded caller is our function id\n        if (encodedFunctionId != functionId) {\n            revert("Invalid sender");\n        }\n\n        // set the random value\n        randomValue = value;\n\n        // emit an event\n        emit NewRandomValue(value);\n    }\n}\n')),(0,r.kt)("h2",{id:"source-code"},"Source Code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"//SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ISwitchboard {\n    //=========================================================================\n    // Events\n    //=========================================================================\n\n    // [Function Calls]\n    event FunctionCallFund(\n        address indexed functionId,\n        address indexed funder,\n        uint256 indexed amount\n    );\n    event FunctionCallEvent(\n        address indexed functionId,\n        address indexed sender,\n        address indexed callId,\n        bytes params\n    );\n\n    // [Functions]\n    event FunctionFund(\n        address indexed functionId,\n        address indexed funder,\n        uint256 indexed amount\n    );\n    event FunctionWithdraw(\n        address indexed functionId,\n        address indexed withdrawer,\n        uint256 indexed amount\n    );\n    event FunctionAccountInit(\n        address indexed authority,\n        address indexed accountId\n    );\n\n    // [Attestation Queues]\n    event AttestationQueueAccountInit(\n        address indexed authority,\n        address indexed accountId\n    );\n    event AddMrEnclave(address indexed queueId, bytes32 mrEnclave);\n    event RemoveMrEnclave(address indexed queueId, bytes32 mrEnclave);\n    event AttestationQueueSetConfig(\n        address indexed queueId,\n        address indexed authority\n    );\n    event AttestationQueuePermissionUpdated(\n        address indexed queueId,\n        address indexed granter,\n        address indexed grantee,\n        uint256 permission\n    );\n\n    // [Enclaves]\n    event EnclaveAccountInit(address indexed signer, address indexed accountId);\n    event EnclaveHeartbeat(address indexed enclaveId, address indexed signer);\n    event EnclaveGC(address indexed enclaveId, address indexed queue);\n    event EnclavePayoutEvent(\n        address indexed nodeId,\n        address indexed enclaveId,\n        uint256 indexed amount\n    );\n    event EnclaveVerifyRequest(\n        address indexed queueId,\n        address indexed verifier,\n        address indexed verifiee\n    );\n    event EnclaveRotateSigner(\n        address indexed queueId,\n        address indexed oldSigner,\n        address indexed newSigner\n    );\n\n    //=========================================================================\n    // Structs\n    //=========================================================================\n\n    // [Function Calls]\n    struct FunctionCall {\n        address functionId;\n        address caller;\n        uint256 timestamp;\n        bytes callData;\n        bool executed;\n        uint256 consecutiveFailures;\n        uint256 feePaid;\n    }\n\n    struct FunctionCallSettings {\n        // require the function call to pay the estimated run cost fee\n        bool requireEstimatedRunCostFee;\n        // minimum fee that a function call must pay\n        uint256 minimumFee;\n        // maximum gas cost that a function call can cost\n        uint256 maxGasCost;\n        // fail calls if the caller does not pay the full cost of the call\n        bool requireCallerPayFullCost;\n        // requires the callback target to be the caller contract\n        bool requireSenderBeReturnAddress;\n    }\n\n    // [Functions]\n    enum FunctionStatus {\n        NONE,\n        ACTIVE,\n        NON_EXECUTABLE,\n        EXPIRED,\n        OUT_OF_FUNDS,\n        INVALID_PERMISSIONS,\n        DEACTIVATED\n    }\n\n    struct SbFunction {\n        string name;\n        address authority;\n        address enclaveId;\n        address queueId;\n        uint256 balance;\n        FunctionStatus status;\n        FunctionConfig config;\n        FunctionState state;\n    }\n\n    struct FunctionConfig {\n        string schedule;\n        address[] permittedCallers;\n        string containerRegistry;\n        string container;\n        string version;\n        string paramsSchema;\n        bytes32[] mrEnclaves;\n        bool allowAllFnCalls;\n        bool useFnCallEscrow;\n    }\n\n    struct FunctionState {\n        uint256 consecutiveFailures;\n        uint256 lastExecutionTimestamp;\n        uint256 nextAllowedTimestamp;\n        uint256 lastExecutionGasCost;\n        uint256 triggeredSince; // first call time in seconds\n        uint256 triggerCount; // number of calls\n        // queueIdx should only be referenced off-chain\n        // - and only with modulo queue length in case the queue is resized\n        uint256 queueIdx;\n        bool triggered;\n        uint256 createdAt;\n    }\n\n    // [Attestation Queues]\n    struct AttestationQueue {\n        address authority;\n        address[] data;\n        uint256 maxSize;\n        uint256 reward;\n        uint256 lastHeartbeat;\n        bytes32[] mrEnclaves;\n        uint256 maxEnclaveVerificationAge;\n        uint256 allowAuthorityOverrideAfter;\n        uint256 maxConsecutiveFunctionFailures;\n        bool requireAuthorityHeartbeatPermission; // require heartbeat permission to heartbeat\n        bool requireUsagePermissions; // require permissions to enclave verify\n        // queue state tracking\n        uint256 enclaveTimeout;\n        uint256 gcIdx;\n        uint256 currIdx;\n    }\n\n    // [Enclaves]\n    enum VerificationStatus {\n        PENDING,\n        FAILURE,\n        SUCCESS,\n        OVERRIDE\n    }\n\n    struct Enclave {\n        address signer;\n        address authority;\n        address queueId;\n        bytes cid;\n        VerificationStatus verificationStatus;\n        uint256 verificationTimestamp;\n        uint256 validUntil;\n        bytes32 mrEnclave;\n        // verifiers\n        bool isOnQueue;\n        uint256 lastHeartbeat;\n        // balance of the Enclave\n        uint256 balance;\n    }\n\n    //=========================================================================\n    // User Functions\n    //=========================================================================\n\n    // [Function Calls]\n\n    /**\n     * Call a function with params - and pay into the function's escrow (if applicable)\n     * @param functionId the function's id to be called\n     * @param params arbitrary data encoded and passed to the function (for off-chain use)\n     * @return callId the call's id\n     * @dev reverts if the function does not exist\n     * @dev reverts if the caller's address is not allowed to call the function\n     * @dev reverts if the function isn't called with enough funding\n     * @dev emits FunctionCallEvent\n     * @dev emits FunctionCallFund if the function call is funded\n     */\n    function callFunction(\n        address functionId,\n        bytes calldata params\n    ) external payable returns (address callId);\n\n    /**\n     * Get estimated run cost for a function (based on last run + gas price)\n     * - this is just supposed to predict gas cost of running a function\n     * @param functionId the function's id\n     * @param gasPrice the gas price to use for the estimate\n     */\n    function estimatedRunCost(\n        address functionId,\n        uint256 gasPrice\n    ) external view returns (uint256);\n\n    /**\n     * Set parameters around calling functions - each of these defaults to 0 / false / empty\n     * @param functionId the function's id\n     * @param requireEstimatedRunCostFee require that the payment be at least the estimated run cost\n     * (uses recent runs for gas cost estimation, so first is the least expensive)\n     * @param minimumFee minimum fee that a function caller must pay\n     * @param maxGasCost maximum gas cost that a function run can cost\n     * @param requireCallerPayFullCost require that the caller pay the full cost of the call\n     * @param requireSenderBeReturnAddress require that the callback target be the caller contract\n     * @dev reverts if the caller is not the function's authority\n     */\n    function setFunctionCallSettings(\n        address functionId,\n        bool requireEstimatedRunCostFee,\n        uint256 minimumFee,\n        uint256 maxGasCost,\n        bool requireCallerPayFullCost,\n        bool requireSenderBeReturnAddress\n    ) external;\n\n    /**\n     * Get a function call by callId\n     * @param callId the call's id\n     * @return FunctionCall struct for the call\n     */\n    function functionCalls(\n        address callId\n    ) external view returns (FunctionCall memory);\n\n    /**\n     * Get a function call's settings\n     * @param functionId the function's id\n     * @return FunctionCallSettings struct for the function\n     */\n    function functionCallSettings(\n        address functionId\n    ) external view returns (FunctionCallSettings memory);\n\n    // [Functions]\n\n    /**\n     * Create a function with a particular id\n     * @param functionId the function's id\n     * @param name name exposed to the Switchboard Explorer\n     * @param authority the function's authority\n     * @param queueId the function's queue (which will resolve function runs)\n     * @param containerRegistry \"dockerhub\"\n     * @param container container name, ex: \"switchboardlabs/function-example\"\n     * @param version container version tag, ex: \"latest\"\n     * @param schedule cron schedule, ex: \"0 * * * *\"\n     * @param paramsSchema json schema for the function's params\n     * @param permittedCallers array of addresses that are allowed to call the function (empty array for all)\n     * @dev emits FunctionAccountInit event\n     */\n    function createFunctionWithId(\n        address functionId,\n        string calldata name,\n        address authority,\n        address queueId,\n        string calldata containerRegistry,\n        string calldata container,\n        string calldata version,\n        string calldata schedule,\n        string calldata paramsSchema,\n        address[] calldata permittedCallers\n    ) external payable;\n\n    /**\n     * Set parameters around calling functions - each of these defaults to 0 / false / empty\n     * @param functionId the function's id\n     * @param name name exposed to the Switchboard Explorer\n     * @param authority the function's authority\n     * @param containerRegistry \"dockerhub\"\n     * @param container container name, ex: \"switchboardlabs/function-example\"\n     * @param version container version tag, ex: \"latest\"\n     * @param schedule cron schedule, ex: \"0 * * * *\"\n     * @param paramsSchema json schema for the function's params\n     * @param permittedCallers array of addresses that are allowed to call the function (empty array for all)\n     * @dev reverts if the caller is not the function's authority\n     */\n    function setFunctionConfig(\n        address functionId,\n        string calldata name,\n        address authority,\n        string calldata containerRegistry,\n        string calldata container,\n        string calldata version,\n        string calldata schedule,\n        string calldata paramsSchema,\n        address[] calldata permittedCallers\n    ) external;\n\n    /**\n     * Fund a function's escrow\n     * @param accountId the function's id\n     * @dev emits FunctionFund event\n     */\n    function functionEscrowFund(address accountId) external payable;\n\n    /**\n     * Withdraw from a function's escrow\n     * @param recipient recipient address\n     * @param functionId the function's id\n     * @param amount the amount to withdraw\n     * @dev reverts if the caller is not the function's authority\n     * @dev emits FunctionWithdraw event\n     */\n    function functionEscrowWithdraw(\n        address payable recipient,\n        address functionId,\n        uint256 amount\n    ) external;\n\n    /**\n     * Check if function exists\n     * @param functionId the function's id\n     * @return bool true if the function exists\n     */\n    function functionExists(address functionId) external view returns (bool);\n\n    /**\n     * Get a function by id\n     * @param functionId the function's id\n     * @return SbFunction struct for the function\n     */\n    function funcs(\n        address functionId\n    ) external view returns (SbFunction memory);\n\n    /**\n     * Get the allowed callers for a function\n     * @param functionId the function's id\n     */\n    function getFunctionPermittedCallers(\n        address functionId\n    ) external view returns (address[] memory);\n\n    /**\n     * Get all functions and their addresses\n     * @return address[] array of function ids\n     * @return SbFunction[] array of functions\n     * @dev addresses returned and functions returned will be the same length\n     */\n    function getAllFunctions()\n        external\n        view\n        returns (address[] memory, SbFunction[] memory);\n\n    /**\n     * Get all functions by authority and their addresses\n     * @param user the user's address\n     * @return address[] array of function ids\n     * @return SbFunction[] array of functions\n     * @dev addresses returned and functions returned will be the same length\n     */\n    function getFunctionsByAuthority(\n        address user\n    ) external view returns (address[] memory, SbFunction[] memory);\n\n    /**\n     * Get the allowed enclave measurements for a function\n     * @param functionId the function's id\n     */\n    function getFunctionMrEnclaves(\n        address functionId\n    ) external view returns (bytes32[] memory);\n\n    /**\n     * Add an allowed enclave measurement to a function\n     * @param functionId the function's id\n     * @param mrEnclave the enclave measurement\n     * @dev reverts if the caller is not the function's authority\n     */\n    function addMrEnclaveToFunction(\n        address functionId,\n        bytes32 mrEnclave\n    ) external;\n\n    /**\n     * Remove an enclave measurement from a function\n     * @param functionId the function's id\n     * @param mrEnclave the enclave measurement to remove\n     * @dev reverts if the caller is not the function's authority\n     */\n    function removeMrEnclaveFromFunction(\n        address functionId,\n        bytes32 mrEnclave\n    ) external;\n\n    // [Attestation Queues]\n\n    /**\n     * Get an attestation queue by id\n     * @param queueId queue's id\n     * @return AttestationQueue struct\n     */\n    function attestationQueues(\n        address queueId\n    ) external view returns (AttestationQueue memory);\n\n    // [Enclaves]\n\n    /**\n     * Get an enclave by ID\n     * @param enclaveId the enclave's id\n     */\n    function enclaves(address enclaveId) external view returns (Enclave memory);\n\n    //=========================================================================\n    // Switchboard Internal Functions\n    //=========================================================================\n\n    // [Attestation Queues]\n\n    /**\n     * Check if an attestation queue allows a particular enclave measurement to verify\n     * @param queueId the queue's id\n     * @param mrEnclave the enclave measurement\n     * @return bool true if the queue allows the enclave to verify\n     */\n    function attestationQueueHasMrEnclave(\n        address queueId,\n        bytes32 mrEnclave\n    ) external view returns (bool);\n\n    /**\n     * Get an enclave's index on the Attestation Queue\n     * @param enclaveId the enclave's id\n     * @return int256 the enclave's index on the queue\n     * @dev returns -1 if the enclave is not on the queue\n     */\n    function getEnclaveIdx(address enclaveId) external view returns (int256);\n\n    /**\n     * Get all allowed enclave measurements for a given queue\n     * @param queueId the queue's id\n     * @return bytes32[] array of enclave measurements\n     */\n    function getAttestationQueueMrEnclaves(\n        address queueId\n    ) external view returns (bytes32[] memory);\n\n    /**\n     * Get an array of all enclaves on a given queue\n     * @param queueId the queue's id\n     */\n    function getEnclaves(\n        address queueId\n    ) external view returns (address[] memory);\n\n    /**\n     * Create an Attestation Queue\n     * @param authority the queue's authority\n     * @param maxSize max number of enclaves allowed on the queue\n     * @param reward reward for enclave verification\n     * @param enclaveTimeout time in seconds before an enclave is timed out\n     * @param maxEnclaveVerificationAge max age in seconds for an enclave verification\n     * @param allowAuthorityOverrideAfter time in seconds before the authority can override an enclave\n     * @param requireAuthorityHeartbeatPermission require authority permissions for enclave heartbeat\n     * @param requireUsagePermissions require permissions for using the queue\n     * @param maxConsecutiveFunctionFailures max number of consecutive function failures before an enclave is timed out\n     * @dev emits AttestationQueueAccountInit event\n     */\n    function createAttestationQueue(\n        address authority,\n        uint256 maxSize,\n        uint256 reward,\n        uint256 enclaveTimeout,\n        uint256 maxEnclaveVerificationAge,\n        uint256 allowAuthorityOverrideAfter,\n        bool requireAuthorityHeartbeatPermission,\n        bool requireUsagePermissions,\n        uint256 maxConsecutiveFunctionFailures\n    ) external;\n\n    /**\n     * Set an Attestation Queue's config\n     * @param queueId the queue's id\n     * @param authority the queue's authority\n     * @param maxSize max number of enclaves allowed on the queue\n     * @param reward reward for enclave verification\n     * @param enclaveTimeout time in seconds before an enclave is timed out\n     * @param maxEnclaveVerificationAge max age in seconds for an enclave verification\n     * @param allowAuthorityOverrideAfter time in seconds before the authority can override an enclave\n     * @param requireAuthorityHeartbeatPermission require authority permissions for enclave heartbeat\n     * @param requireUsagePermissions require permissions for using the queue\n     * @param maxConsecutiveFunctionFailures max number of consecutive function failures before an enclave is timed out\n     * @dev reverts if the caller is not the queue's authority\n     * @dev emits AttestationQueueSetConfig event\n     */\n    function setAttestationQueueConfig(\n        address queueId,\n        address authority,\n        uint256 maxSize,\n        uint256 reward,\n        uint256 enclaveTimeout,\n        uint256 maxEnclaveVerificationAge,\n        uint256 allowAuthorityOverrideAfter,\n        bool requireAuthorityHeartbeatPermission,\n        bool requireUsagePermissions,\n        uint256 maxConsecutiveFunctionFailures\n    ) external;\n\n    /**\n     * Add an enclave measurement to an attestation queue\n     * @param queueId the queue's id\n     * @param mrEnclave the enclave measurement\n     * @dev reverts if the caller is not the queue's authority\n     * @dev emits AddMrEnclave event\n     */\n    function addMrEnclaveToAttestationQueue(\n        address queueId,\n        bytes32 mrEnclave\n    ) external;\n\n    /**\n     * Remove an enclave measurement from an attestation queue\n     * @param queueId the queue's id\n     * @param mrEnclave the enclave measurement\n     * @dev reverts if the caller is not the queue's authority\n     * @dev emits RemoveMrEnclave event\n     */\n    function removeMrEnclaveFromAttestationQueue(\n        address queueId,\n        bytes32 mrEnclave\n    ) external;\n\n    /**\n     * Set an attestation queue's permissions\n     * @param queueId the queue's id\n     * @param grantee the address to grant permissions to\n     * @param permission the permission to grant\n     * @param on true if the permission should be granted\n     * @dev reverts if the caller is not the queue's authority\n     * @dev emits AttestationQueuePermissionUpdated event\n     */\n    function setAttestationQueuePermission(\n        address queueId,\n        address grantee,\n        uint256 permission,\n        bool on\n    ) external;\n\n    // [Enclaves]\n\n    /**\n     * Get a signer's associated enclaveId\n     * @param signer the enclave's signer\n     * @return enclaveId the enclave's id\n     * @dev returns address(0) if the enclave does not exist\n     */\n    function enclaveSignerToEnclaveId(\n        address signer\n    ) external view returns (address);\n\n    /**\n     * Validate that a signer has a valid queue\n     * @param signer signer's address\n     * @param attestationQueueId the queue's id\n     * @param validMeasurements  array of valid enclave measurements\n     * @dev reverts if the signer does not have a valid enclave\n     */\n    function validate(\n        address signer,\n        address attestationQueueId,\n        bytes32[] memory validMeasurements\n    ) external view;\n\n    /**\n     * Check if an enclave is valid\n     * @param enclaveId the enclave's id\n     * @return bool true if the enclave is valid\n     */\n    function isEnclaveValid(address enclaveId) external view returns (bool);\n\n    /**\n     * Create an enclave account\n     * @param signer the enclave's signer address\n     * @param queueId the enclave's queue\n     * @param authority the enclave authority\n     * @dev emits EnclaveAccountInit event\n     */\n    function createEnclave(\n        address signer,\n        address queueId,\n        address authority\n    ) external;\n\n    /**\n     * Create an enclave account with a particular Id\n     * @param enclaveId the enclave's id\n     * @param signer the enclave's signer address\n     * @param queueId the enclave's queue\n     * @param authority the enclave authority\n     * @dev emits EnclaveAccountInit event\n     */\n    function createEnclaveWithId(\n        address enclaveId,\n        address signer,\n        address queueId,\n        address authority\n    ) external;\n\n    /**\n     * @param enclaveId the enclave's id\n     * @param cid the quote content address\n     * @dev emits EnclaveVerifyRequest\n     */\n    function updateEnclave(\n        address enclaveId,\n        bytes calldata cid\n    ) external payable;\n\n    /**\n     * Override an enclave's verification status to initialize a queue\n     * @param enclaveId the enclave's id\n     * @dev reverts if the caller is not the queue's authority\n     */\n    function forceOverrideVerify(address enclaveId) external;\n\n    /**\n     * Try garbage collecting an enclave from a queue\n     * @param enclaveId the enclave to gc\n     * @param enclaveIdx the enclave's index on the queue\n     * @dev emits EnclaveGC if the enclave is garbage collected\n     */\n    function enclaveGarbageCollect(\n        address enclaveId,\n        uint256 enclaveIdx\n    ) external;\n\n    /**\n     * Fail an enclave / deny verification\n     * @param verifierId the verifying enclave's id\n     * @param enclaveId enclave id\n     * @param verifierIdx the verifier's index on the queue\n     * @dev emits EnclavePayoutEvent\n     */\n    function failEnclave(\n        address verifierId,\n        address enclaveId,\n        uint256 verifierIdx\n    ) external;\n\n    /**\n     * Verify enclave\n     * @param verifierId verifying enclave id\n     * @param enclaveId enclave id to verify\n     * @param enclaveIdx verifier's index on the queue\n     * @param timestamp timestamp of the verification\n     * @param mrEnclave enclave measurement\n     * @dev emits EnclavePayoutEvent\n     */\n    function verifyEnclave(\n        address verifierId,\n        address enclaveId,\n        uint256 enclaveIdx,\n        uint256 timestamp,\n        bytes32 mrEnclave\n    ) external;\n\n    /**\n     * Heartbeat enclave onto queue\n     * @param enclaveId enclave id\n     * @dev emits EnclaveHeartbeat event\n     * @dev emits EnclaveGC event if the enclave is garbage collected\n     */\n    function enclaveHeartbeat(address enclaveId) external;\n\n    /**\n     * Swap enclave signers\n     * @param enclaveId enclave id\n     * @param newSigner new signer address\n     * @dev will require an enclave verification or force override to actually heartbeat\n     * @dev emits EnclaveRotateSigner\n     */\n    function rotateEnclaveSigner(address enclaveId, address newSigner) external;\n\n    // [Function Calls]\n    /**\n     * Get all active functions by queue id\n     * @param queueId the queue's id\n     * @return address[] array of function ids on the queue (in order)\n     * @return FunctionCall[] array of function calls on the queue (in order)\n     * @dev addresses returned and functionCalls returned will be the same length\n     */\n    function getActiveFunctionCallsByQueue(\n        address queueId\n    ) external view returns (address[] memory, FunctionCall[] memory);\n\n    // [Functions]\n    /**\n     * Create a function with a particular id\n     * @param name name exposed to the Switchboard Explorer\n     * @param authority the function's authority\n     * @param queueId the function's queue (which will resolve function runs)\n     * @param containerRegistry \"dockerhub\"\n     * @param container container name, ex: \"switchboardlabs/function-example\"\n     * @param version container version tag, ex: \"latest\"\n     * @param schedule cron schedule, ex: \"0 * * * *\"\n     * @param paramsSchema json schema for the function's params\n     * @param permittedCallers array of addresses that are allowed to call the function (empty array for all)\n     * @dev emits FunctionAccountInit event\n     */\n    function createFunction(\n        string calldata name,\n        address authority,\n        address queueId,\n        string calldata containerRegistry,\n        string calldata container,\n        string calldata version,\n        string calldata schedule,\n        string calldata paramsSchema,\n        address[] calldata permittedCallers\n    ) external payable;\n\n    /**\n     * Get all active functions by queue id\n     * @param queueId the queue's id\n     * @return address[] array of function ids on the queue (in order)\n     * @return SbFunction[] array of functions on the queue (in order)\n     * @dev addresses returned and functions returned will be the same length\n     */\n    function getActiveFunctionsByQueue(\n        address queueId\n    ) external view returns (address[] memory, SbFunction[] memory);\n\n    /**\n     * Get the eip712 hash for a function call\n     * @param expirationTimeSeconds revert if past this time in seconds\n     * @param gasLimit gas limit for the function call\n     * @param value value to send with the function call\n     * @param to the target for this function call\n     * @param from the caller for this function call\n     * @param data the encoded function call data\n     * @return bytes32 the eip712 hash\n     */\n    function getTransactionHash(\n        uint256 expirationTimeSeconds,\n        uint256 gasLimit,\n        uint256 value,\n        address to,\n        address from,\n        bytes calldata data\n    ) external view returns (bytes32);\n\n    /**\n     * Account for function run and execute function call\n     * @param enclaveIdx enclave idx on the queue\n     * @param functionId the function's id\n     * @param delegatedSignerAddress the delegated signer's address (enclave signer)\n     * @param observedTime the observed time of the function call\n     * @param nextAllowedTimestamp the next allowed timestamp for the function call\n     * @param isFailure true if the function call failed\n     * @param mrEnclave enclave measurement\n     * @param transactionsData array of transaction data\n     * @param signatures array of signatures\n     * @dev reverts if the caller is not a verified enclave authority\n     */\n    function functionVerify(\n        uint256 enclaveIdx,\n        address functionId,\n        address delegatedSignerAddress,\n        uint256 observedTime,\n        uint256 nextAllowedTimestamp,\n        bool isFailure,\n        bytes32 mrEnclave,\n        bytes32[] calldata transactionsData,\n        bytes[] calldata signatures\n    ) external;\n\n    /**\n     * Account for function run and execute function call, resolving a number of FuncionCalls\n     * @param enclaveIdx enclave idx on the queue\n     * @param functionId the function's id\n     * @param delegatedSignerAddress the delegated signer's address (enclave signer)\n     * @param observedTime the observed time of the function call\n     * @param nextAllowedTimestamp the next allowed timestamp for the function call\n     * @param isFailure true if the function call failed\n     * @param mrEnclave enclave measurement\n     * @param transactionsData array of transaction data\n     * @param signatures array of signatures\n     * @param functionCallIds array of function call ids\n     * @dev reverts if the caller is not a verified enclave authority\n     */\n    function functionVerifyRequest(\n        uint256 enclaveIdx,\n        address functionId,\n        address delegatedSignerAddress,\n        uint256 observedTime,\n        uint256 nextAllowedTimestamp,\n        bool isFailure,\n        bytes32 mrEnclave,\n        bytes32[] calldata transactionsData,\n        bytes[] calldata signatures,\n        address[] calldata functionCallIds\n    ) external;\n\n    /**\n     * Execute function call\n     * @param transactionsData array of transaction data\n     * @param signatures array of signatures\n     * @dev reverts if the caller is not allocated permissions by admin\n     */\n    function forward(\n        bytes32[] calldata transactionsData,\n        bytes[] calldata signatures\n    ) external payable;\n\n    /**\n     * Deactivate a function - can only be called by queue authority\n     * @param functionId function id for deactivation\n     */\n    function setFunctionDeactivated(address functionId) external;\n\n    /**\n     * Set the tolerated discrepancy between enclave reported time and on-chain time\n     * @param tolerance the tolerance in seconds\n     * @dev can only be called by contract admin\n     */\n    function setToleratedTimestampDiscrepancy(uint256 tolerance) external;\n}\n")))}m.isMDXComponent=!0}}]);